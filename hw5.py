import pathlib
from typing import Union, Tuple
import json
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

class QuestionnaireAnalysis:
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """

    def __init__(self, data_fname: Union[pathlib.Path, str]):
        if isinstance(data_fname, str):
            path = pathlib.Path(data_fname)
        elif isinstance(data_fname, pathlib.Path):
            path = data_fname
        else:
            raise TypeError("data_fname must be a string or pathlib.Path object")
        if not path.exists():
            raise ValueError(f"Data file {path} does not exist.")
        self.data_fname = path
        self.data = None

    def read_data(self):
        """Reads JSON from file into self.data as a pandas DataFrame."""
        with self.data_fname.open('r', encoding='utf-8') as f:
            raw = json.load(f)
        df = pd.DataFrame(raw)
        # Convert questions and age to numeric, treating the literal 'nan' as missing
        qcols = ["q1", "q2", "q3", "q4", "q5"]
        df[qcols] = df[qcols].replace('nan', np.nan).apply(pd.to_numeric, errors='coerce')
        df['age'] = df['age'].replace('nan', np.nan).apply(pd.to_numeric, errors='coerce')
        self.data = df

    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants."""
        if self.data is None:
            raise ValueError("Data has not been read. Call read_data() first.")
        ages = self.data['age'].dropna().to_numpy()
        hist, bins = np.histogram(ages, bins=np.arange(0, 110, 10))
        plt.figure()
        plt.bar(bins[:-1], hist, width=np.diff(bins), edgecolor='black', align='edge')
        plt.xlabel('Age')
        plt.ylabel('Number of Participants')
        plt.title('Age Distribution of Participants')
        plt.xticks(bins)
        plt.grid(axis='y')
        plt.close()
        return hist, bins

    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Removes rows with invalid email format and resets index."""
        if self.data is None:
            raise ValueError("Data has not been read. Call read_data() first.")
        df = self.data.copy()
        valid = df['email'].str.contains(r'^[\w][\w\.-]+@[\w\.-]+\.\w+$', na=False)
        df = df[valid].reset_index(drop=True)
        return df

    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        """Fills missing question answers with the per-subject mean."""
        if self.data is None:
            raise ValueError("Data has not been read. Call read_data() first.")
        df = self.data.copy()
        qcols = ["q1", "q2", "q3", "q4", "q5"]
        mask = df[qcols] == 'nan'
        # if literal 'nan' remained, convert to np.nan
        df[qcols] = df[qcols].replace('nan', np.nan)
        mask = df[qcols].isna()
        rows = np.where(mask.any(axis=1))[0]
        for i in rows:
            mean_val = df.loc[i, qcols].mean(skipna=True)
            df.loc[i, qcols] = df.loc[i, qcols].fillna(mean_val)
        return df, rows

    def score_subjects(self, maximal_nans_per_sub: int = 1) -> pd.DataFrame:
            """Calculates the average score of a subject and adds a new "score" column
            with dtype UInt8, flooring the mean and placing <NA> if too many NaNs."""
            if self.data is None:
                raise ValueError("Data has not been read. Call read_data() first.")

            # Work on a copy
            df = self.data.copy()
            qcols = ["q1", "q2", "q3", "q4", "q5"]

            # 1) Count how many NaNs each subject has
            missing_counts = df[qcols].isna().sum(axis=1)

            # 2) Compute the mean of the non-missing answers
            mean_scores = df[qcols].mean(axis=1, skipna=True)

            # 3) For subjects with too many NaNs, set to NA
            mean_scores[missing_counts > maximal_nans_per_sub] = pd.NA

            # 4) Floor the means and cast to the UInt8 extension type
            df["score"] = np.floor(mean_scores).astype("UInt8")

            return df
    

    def correlate_gender_age(self) -> pd.DataFrame:
        """Groups by gender and age>40, returns question means."""
        if self.data is None:
            raise ValueError("Data has not been read. Call read_data() first.")
        df = self.data.copy()
        qcols = ["q1","q2","q3","q4","q5"]
        # Drop rows without valid age
        df = df.dropna(subset=['age'])
        # Build a boolean age flag and overwrite 'age'
        df['age'] = df['age'] > 40
        # Group and mean
        result = df.groupby(['gender','age'])[qcols].mean()
        return result

